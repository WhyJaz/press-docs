## 什么是MVVM？

* View：界面
* Model：数据模型
* ViewModel：作为桥梁负责沟通 View 和 Model
在 JQuery 时期，如果需要更新 UI，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。并且而且不利于代码复用

而在 MVVM 中，UI 是通过数据来驱动的，VM 负责沟通 view 和 model，VM 的通信是双向的，view 数据的变化会同步到 model 上，model 数据的变化也会响应在 view 上。种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。这样开发者就不必关注于操作 DOM 层面，而只需要专注开发核心的业务逻辑

在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

<br/>



## 为什么组件的data选项是一个函数？

从组件本身的定义来说，组件应该是一个独立的模块，它拥有自己的数据，方法，html 模板，并且可以被复用在任何地方。所以一个组件不管被复用多少次，组件中的 data 都应该是相互隔离，互不影响的。

而在 js 中 object 是一个引用数据类型，如果我们直接给 data 赋值为一个对象，那么在其他地方复用该组件时，将会共享这个引用数据的内存地址，会造成修改了一个组件的数据，另一个组件的数据也会被修改，这显然不是我们想要看到的，所以我们将 data 设定为一个函数，这样组件在每次被复用时，将会执行这个 data 函数，从而生成一份新的数据，这样就实现了组件复用的数据隔离。

<br/>


## 生命周期及父子组件生命周期的执行顺序？
* beforeCreate：实例初始化完成，但数据和事件还未完成注入
* created：data 和方法已完成注入，但还没有开始 DOM 编译
* beforeMount：已完成 template 的解析，完成了虚拟 DOM 的编译，但还未渲染到页面上
* mounted：已将虚拟 DOM 渲染完成到页面上，可以获取操作 DOM 了
* beforeUpdate：有 data 或 props 改变时触发，此时还未完成更新
* updated：此时已完成页面 DOM 的更新
* beforeMount：组件卸载前，此时还可以获取到实例的数据和方法

render 阶段：
<br/>
执行顺序：beforeCreate - 父 created - 父 beforeMount - 子 beforeCreate - 子 created - 子 beforeMount - 子 mounted - 父 mounted

update 阶段：
* 情况一：父子组件只是嵌套情况，并没有数据的互相引用；
父子组件各自的 data 更新时，只执行自己的 beforeUpdate 和 updated
* 情况二：子组件引用了父组件的 data；
父 beforeUpdate - 子 beforeUpdate - 子 updated - 父 updated

<br/>

## 为什么vuex中异步不能直接commit
主要是为了方便 devtool 的调试，可以清楚地知道上一秒和下一秒值的快照，而如果是一个异步的话，会让值的顺序变得不可预期，不利于调试