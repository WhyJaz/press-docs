<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>输入一个URL发生的全过程 | 前端装逼大全</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/vuepress-doc/assets/css/0.styles.ced9e313.css" as="style"><link rel="preload" href="/vuepress-doc/assets/js/app.d9784184.js" as="script"><link rel="preload" href="/vuepress-doc/assets/js/2.f1eb8907.js" as="script"><link rel="preload" href="/vuepress-doc/assets/js/9.8b5001ef.js" as="script"><link rel="prefetch" href="/vuepress-doc/assets/js/10.8825ea12.js"><link rel="prefetch" href="/vuepress-doc/assets/js/11.4bb440f0.js"><link rel="prefetch" href="/vuepress-doc/assets/js/12.ea893531.js"><link rel="prefetch" href="/vuepress-doc/assets/js/13.967ecace.js"><link rel="prefetch" href="/vuepress-doc/assets/js/14.c4053477.js"><link rel="prefetch" href="/vuepress-doc/assets/js/15.f6260ae3.js"><link rel="prefetch" href="/vuepress-doc/assets/js/16.139df0c3.js"><link rel="prefetch" href="/vuepress-doc/assets/js/17.d06b938a.js"><link rel="prefetch" href="/vuepress-doc/assets/js/18.681e5bc8.js"><link rel="prefetch" href="/vuepress-doc/assets/js/19.ecdebcf9.js"><link rel="prefetch" href="/vuepress-doc/assets/js/20.36e33e70.js"><link rel="prefetch" href="/vuepress-doc/assets/js/21.8d74520d.js"><link rel="prefetch" href="/vuepress-doc/assets/js/22.391e7403.js"><link rel="prefetch" href="/vuepress-doc/assets/js/3.bbfca75e.js"><link rel="prefetch" href="/vuepress-doc/assets/js/4.4ebeb892.js"><link rel="prefetch" href="/vuepress-doc/assets/js/5.c39cf72a.js"><link rel="prefetch" href="/vuepress-doc/assets/js/6.4200871d.js"><link rel="prefetch" href="/vuepress-doc/assets/js/7.4b990687.js"><link rel="prefetch" href="/vuepress-doc/assets/js/8.56cbd3d9.js">
    <link rel="stylesheet" href="/vuepress-doc/assets/css/0.styles.ced9e313.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-doc/" class="home-link router-link-active"><!----> <span class="site-name">前端装逼大全</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-doc/contents/js/数据类型.html" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/vuepress-doc/contents/js/数据类型.html" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/WhyJaz/vuepress-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-doc/contents/js/数据类型.html" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/vuepress-doc/contents/js/数据类型.html" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="https://github.com/WhyJaz/vuepress-doc" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Browser</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-doc/contents/browser/客户端存储.html" class="sidebar-link">客户端存储</a></li><li><a href="/vuepress-doc/contents/browser/网络请求.html" class="active sidebar-link">网络请求</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#输入一个url发生的全过程" class="sidebar-link">输入一个URL发生的全过程</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#http-概述" class="sidebar-link">HTTP 概述</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#同源策略" class="sidebar-link">同源策略</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#http-与-https" class="sidebar-link">http 与 https</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#常见的-http-状态码" class="sidebar-link">常见的 http 状态码</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#get-和-post-的区别" class="sidebar-link">get 和 post 的区别？</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#tcp的三次握手、4次挥手" class="sidebar-link">TCP的三次握手、4次挥手</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#跨域" class="sidebar-link">跨域</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#cookie-与-session" class="sidebar-link">cookie 与 session</a></li><li class="sidebar-sub-header"><a href="/vuepress-doc/contents/browser/网络请求.html#ajax、fetch、axios的区别" class="sidebar-link">ajax、fetch、axios的区别？</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程试题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="输入一个url发生的全过程"><a href="#输入一个url发生的全过程" class="header-anchor">#</a> 输入一个URL发生的全过程</h2> <ol><li><p>首先根据浏览器的多进程架构，一个页面至少需要4个进程，浏览器主进程、网络进程、渲染进程、GPU进程</p></li> <li><p>浏览器通过进程间的通信（IPC）将 URL 发送给网络进程，网络进程首先查找本地是否缓存了资源，如果有直接返回，没有则走网络流程</p></li> <li><p>网络流程第一步，是做一个 DNS 域名解析，解析出域名对应服务器ip地址，如果是 HTTPS 则还需要建立 TLS 连接</p></li> <li><p>然后建立 TCP 连接，开始三次握手，然后开始正式发送请求</p></li> <li><p>请求在返回数据前，可能会经过负载均衡服务器，将请求合理地分发到对应的服务器上</p></li> <li><p>然后服务器返回一个响应，浏览器接收到响应，开始解析状态码，如果是 301 或者 302，则根据响应头中的 location 字段，进行重定向，400 或者 500 则直接显示错误，200 则继续解析</p></li> <li><p>浏览器根据响应头中的 <code>content-type</code> 开始解析文件，解析完后，浏览器主进程发出一个提交文档消息，让网络进程和渲染进程建立管道，将响应体中的数据发送给渲染引擎准备渲染</p></li></ol> <br> <h2 id="http-概述"><a href="#http-概述" class="header-anchor">#</a> HTTP 概述</h2> <p>URL格式：[Protocol]：//[hostname][:port]/[path]</p> <ul><li>Protocol：指明获取页面的协议</li> <li>Hostname：指明存放web页面的服务器，可以是域名和IP地址</li> <li>Port：指明服务器的端口号，使HTTP访问服务器时，默认端口是80，也可以指定其他端口</li> <li>Path：指明web页面在服务器上存放的位置</li></ul> <br> <h2 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h2> <p>同源是指协议，域名，端口号都相同，只要有任何一个不同，就表示是跨域，即便两个不同的域名指向同一个 ip 地址，也非同源。</p> <br> <h2 id="http-与-https"><a href="#http-与-https" class="header-anchor">#</a> http 与 https</h2> <ul><li><p>http：是一个从客户端到服务端的基于TCP/IP协议上的一个应用层标准通信协议，默认端口80</p></li> <li><p>https：在http基础上采用SSL（安全套接字协议）/TLS（安全传输层）进行加密传输，更加安全，默认端口443，要想使用https，服务端必须去CA申请证书
从本质上来说，两者都是基于传输层协议（TCP/IP）上的一个应用层协议</p></li></ul> <p>简单点说就是：HTTP + 认证 + 加密 + 完整性保护 = HTTPS，由于https 采取加密通信，所以相比较于http的纯文本传输会消耗更多的 CPU 资源，因为在敏感数据的请求上我们会采取https的方式进行加密处理</p> <p>http 与 https 协议的缺点：</p> <p>通信只能由客户端发起，服务端无法向客户端发起通信</p> <br> <h2 id="常见的-http-状态码"><a href="#常见的-http-状态码" class="header-anchor">#</a> 常见的 http 状态码</h2> <ul><li>200：请求成功</li> <li>301：表示请求的资源已分配了新的URL</li> <li>302：临时重定向，表示请求的资源临时分配了新的URL</li> <li>304：浏览器执行了get，但文件并未变化(服务器返回此响应时，不会返回网页内容，调用缓存内容)</li> <li>401：请求被拒绝，需要提供授权信息</li> <li>403：Forbidden，禁止访问(服务器收到请求，但是拒绝提供服务)</li> <li>404：Not Found，服务器无法找到被请求的页面</li> <li>500：服务器内部遇到错误，最常见的服务器端错误</li> <li>503：服务不可用，可能为维护停机或超载</li> <li>504：网关超时，服务器未能快速的做出反应，请求pending过长会导致这个</li></ul> <br> <h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> get 和 post 的区别？</h2> <ul><li><p>get 请求的参数直接暴露在url上，post 则在body中</p></li> <li><p>浏览器（协议本身是没有大小限制的）对GET请求参数大小有限制，大小在2KB，post 理论上无限制</p></li> <li><p>get请求会保存在浏览器历史记录中，数据会被浏览器主动缓存，回退时无害。post请求不会被浏览器缓存，回退时会重新请求</p></li> <li><p>get 会把 header和data一并发送出去，而 post 会产生两个数据包先发送header，服务器返回100，然后再发送data，服务器返回200，并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li> <li><p>GET请求只能进行url编码，而POST支持多种编码方式。</p></li> <li><p>GET只接受ASCII字符，而POST没有限制。</p></li> <li><p>两者安全性其实并没有多大差别，不用https都是明文传输</p></li></ul> <br> <h2 id="tcp的三次握手、4次挥手"><a href="#tcp的三次握手、4次挥手" class="header-anchor">#</a> TCP的三次握手、4次挥手</h2> <h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043744.png" alt="image"></p> <p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工（发送和请求可以同时进行）的协议。
起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p> <h3 id="第一次握手"><a href="#第一次握手" class="header-anchor">#</a> 第一次握手</h3> <p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p> <h3 id="第二次握手"><a href="#第二次握手" class="header-anchor">#</a> 第二次握手</h3> <p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p> <h3 id="第三次握手"><a href="#第三次握手" class="header-anchor">#</a> 第三次握手</h3> <p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p> <p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p> <h3 id="你是否有疑惑明明两次握手就可以建立起连接-为什么还需要第三次应答"><a href="#你是否有疑惑明明两次握手就可以建立起连接-为什么还需要第三次应答" class="header-anchor">#</a> 你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</h3> <p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p> <p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p> <p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p> <h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <h3 id="第一次挥手"><a href="#第一次挥手" class="header-anchor">#</a> 第一次挥手</h3> <p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p> <h3 id="第二次握手-2"><a href="#第二次握手-2" class="header-anchor">#</a> 第二次握手</h3> <p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p> <h3 id="第三次握手-2"><a href="#第三次握手-2" class="header-anchor">#</a> 第三次握手</h3> <p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p> <h3 id="第四次握手"><a href="#第四次握手" class="header-anchor">#</a> 第四次握手</h3> <p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。
为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？
为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p> <br> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <p>因为浏览器的安全策略，所以跨域的请求可以到达服务器，但是服务器并不会响应
常见的跨域方式：</p> <ul><li>JSONP</li> <li>CORS</li> <li>document.domain</li> <li>postMessage</li></ul> <br> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>原理：页面中的 <code>script</code>、<code>img</code>、<code>iframe</code> 标签不受同源策略限制</p> <p>JSONP 的理念就是，与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段  Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。</p> <p>JSONP 的缺点是：它只支持 GET 请求，而不支持 POST 请求等其他类型的 HTTP 请求。</p> <p>以下是 JSONP 的简单实现</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> jsonpCallback<span class="token punctuation">,</span> success</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url
  script<span class="token punctuation">.</span>async <span class="token operator">=</span> <span class="token boolean">true</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  <span class="token comment">// 因为返回的script代码会执行我们的回调，所以我们需要把回调挂载到全局上让它调用</span>
  window<span class="token punctuation">[</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    success <span class="token operator">&amp;&amp;</span> <span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  script<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 错误处理</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://xxx'</span><span class="token punctuation">,</span> <span class="token string">'callback'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h3> <p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p> <h3 id="document-domain"><a href="#document-domain" class="header-anchor">#</a> document.domain</h3> <p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域</p> <h3 id="postmessage"><a href="#postmessage" class="header-anchor">#</a> postMessage</h3> <p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><br> <h2 id="cookie-与-session"><a href="#cookie-与-session" class="header-anchor">#</a> cookie 与 session</h2> <p>参考文章：</p> <ul><li><a href="https://juejin.cn/post/6844903605175058439#heading-19" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903605175058439#heading-19<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903842773991431" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903842773991431<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844904034181070861" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904034181070861<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="为什么会产生-cookie-和-session"><a href="#为什么会产生-cookie-和-session" class="header-anchor">#</a> 为什么会产生 cookie 和 session？</h3> <p>因为http协议是无状态的，通信时并不能携带状态信息，但是实际应用中需要大量使用到鉴权等状态信息，所以产生了 cookie 和 session。</p> <h3 id="cookie机制"><a href="#cookie机制" class="header-anchor">#</a> cookie机制</h3> <p>客户端请求服务器时，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求服务器时，浏览器会把 Cookie 附着在 header 头上一同提交给服务器。服务器通过检查该Cookie来获取用户状态。（默认情况下，header都会携带cookie）</p> <p>对于 cookie 的同源策略，只关注域名是否一致，不关注协议和端口，只要域名一致即可访问到
Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。</p> <h3 id="session机制"><a href="#session机制" class="header-anchor">#</a> session机制</h3> <p>在 session 出现之前，大部分的网站通信都是采用的 cookie 进行通信</p> <p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId。如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）。如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</p> <p>Session 是基于 cookie 实现的。建立一个连接就生成一个session id，打开几个页面就好几个了，这里就用到了Cookie，把session id存在Cookie中，每次访问的时候将Session id带过去就可以识别了</p> <p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p> <p>session有一个缺点，如果服务器做了负载均衡，当下一个请求打到另一台服务器时，session就会丢失</p> <h3 id="cookie-和-session-的区别"><a href="#cookie-和-session-的区别" class="header-anchor">#</a> cookie 和 session 的区别</h3> <p>有效期：Cookie 可设置为长时间保持，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
安全性：Cookie 存储在客户端，比较容易遭到非法获取；Session 存储在服务端，安全性相对 Cookie 要好一些。
存储大小： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。但是当访问量过多，会占用过多的服务器资源。
存储值的类型：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</p> <br> <h2 id="ajax、fetch、axios的区别"><a href="#ajax、fetch、axios的区别" class="header-anchor">#</a> ajax、fetch、axios的区别？</h2> <h3 id="ajax"><a href="#ajax" class="header-anchor">#</a> ajax</h3> <p>缺点：多个请求之间如果相互依赖数据的话，会出现回调地狱</p> <h3 id="fetch"><a href="#fetch" class="header-anchor">#</a> fetch</h3> <p>fetch是基于ES6 promise 的一个实现，支持async、await，在底层上完全重写了，根ajax的 XMLHTTPRequest
优点：书写更加的简洁</p> <p>缺点：
是一个很底层的API，使用时还需要进行一些封装
fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
fetch不支持abort，不支持超时控制
fetch默认不会带cookie，需要添加配置项
fetch没有办法原生监测请求的进度，而XHR可以。</p> <h3 id="axios"><a href="#axios" class="header-anchor">#</a> axios</h3> <p>Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本
特点：
相比ajax它支持promise化的API
提供了一些并发请求的接口
支持拦截请求和响应
支持取消请求
自动转化JSON数据格式</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress-doc/contents/browser/客户端存储.html" class="prev">
        客户端存储
      </a></span> <span class="next"><a href="/vuepress-doc/contents/webpack/webpack基础.html">
        webpack基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress-doc/assets/js/app.d9784184.js" defer></script><script src="/vuepress-doc/assets/js/2.f1eb8907.js" defer></script><script src="/vuepress-doc/assets/js/9.8b5001ef.js" defer></script>
  </body>
</html>
