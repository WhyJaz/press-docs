(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{387:function(v,e,a){"use strict";a.r(e);var _=a(45),r=Object(_.a)({},(function(){var v=this,e=v.$createElement,a=v._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"基本术语"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本术语"}},[v._v("#")]),v._v(" 基本术语：")]),v._v(" "),a("ul",[a("li",[v._v("chunk：从一个入口模块开始，根据所依赖的模块所打包出来的代码，一般一个入口产生一个 chunk")]),v._v(" "),a("li",[v._v("vendor：一般把第三方库提取到 vendor 中，表示不经常变化的的内容")]),v._v(" "),a("li",[v._v("bundle：一般指的是最终的打包结果，可能由多个 chunk 组成")])]),v._v(" "),a("br"),v._v(" "),a("h2",{attrs:{id:"什么是webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是webpack"}},[v._v("#")]),v._v(" 什么是webpack？")]),v._v(" "),a("p",[v._v("webpack 是一个现代化的 JavaScript 应用程序静态模块打包器，当 webpack 开始处理应用程序时，它会在内部构建一个依赖关系图，此依赖图会映射到项目所需的各个模块上，并生成一个或多个 bundle")]),v._v(" "),a("br"),v._v(" "),a("h2",{attrs:{id:"为什么需要使用webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要使用webpack"}},[v._v("#")]),v._v(" 为什么需要使用webpack？")]),v._v(" "),a("ul",[a("li",[v._v("模块打包：帮助我们自由划分业务组件，保证项目结构的清晰和可读性")]),v._v(" "),a("li",[v._v("编译文件：可以让我们使用less、vue、jsx等语法帮助提高开发效率，提供了 "),a("code",[v._v("loader")]),v._v(" 进行转译")]),v._v(" "),a("li",[v._v("兼容处理：转换ES6+语法，tree-shaking打包")]),v._v(" "),a("li",[v._v("能力扩展：提供了 "),a("code",[v._v("plugin")]),v._v("  帮助我们实现代码压缩混淆，提高自动化，")])]),v._v(" "),a("p",[v._v("在 web 中我们使用 js 文件无非有两种方式：")]),v._v(" "),a("ul",[a("li",[v._v("将各个功能独立的代码分成几个 js 文件，然后用 script 标签加载，但是加载过多的 js 文件会造成网络性能瓶颈")]),v._v(" "),a("li",[v._v("将所有代码都放到一个 js 文件中，但是这避免不了作用域混乱，命名空间冲突，维护困难等问题")])]),v._v(" "),a("p",[v._v("所以 "),a("code",[v._v("webpack")]),v._v(" 的作用就是帮助我们解决上面遇到的问题")]),v._v(" "),a("br"),v._v(" "),a("h2",{attrs:{id:"webpack和gulp、grunt的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack和gulp、grunt的区别"}},[v._v("#")]),v._v(" webpack和gulp、grunt的区别？")]),v._v(" "),a("p",[v._v("grunt和gulp是类似的，都是一个task Runner，区别是grunt会将每个任务处理后的文件放在本地磁盘上，就会导致打包速度较慢（涉及到本地磁盘的IO读写），而gulp每个任务流的处理结果会保存在内存中，并且下一个任务流可以读取上一个任务的结果，大大提高了打包速度")]),v._v(" "),a("p",[v._v("gulp是一个基于任务型的工具，它的目的是一个自动化提高生产力，比如我们想用sass写css，ts写js，我们想压缩图片了，传统的方式是我们一个一个地去手动转换，而gulp让我们可以通过配置一些任务，自动地完成这些东西，所以它是一个提高我们手动转换效率的一个工具，而它的工作模式是基于任务流式的，但是它不能解决模块化的问题\n而webpack它本身就是解决模块化问题的，在webpack中，一切皆是模块，通过人口文件递归地构建一个依赖关系图，然后把相关的模块打包输出")]),v._v(" "),a("br"),v._v(" "),a("h2",{attrs:{id:"webpack和rollup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack和rollup"}},[v._v("#")]),v._v(" webpack和rollup?")]),v._v(" "),a("p",[v._v("从webpack的诞生上来说，它是为了解决代码分割，静态资源导入和按需加载而生的，所以在常规的应用开发来说，它更合适。而rollup则对上面几点支持不好，它比较适合做js类库的打包。\n所以如果你的代码只是专注于js，希望做一些ES转换和模块解析，那么使用rollup更为合适，而平常的业务开发webpack更合适。\nrollup：react、vue、vuex、vue-router\nwebpack：element-ui、mint-ui、vue-cli")]),v._v(" "),a("p",[v._v("webpack的构建流程")]),v._v(" "),a("ol",[a("li",[v._v("初始化参数：根据配置文件和shell语句读取并合并参数，生成最终参数")]),v._v(" "),a("li",[v._v("开始编译：用第一步得到的参数初始化一个compiler实例，加载所有配置的插件，执行实例的run方法")]),v._v(" "),a("li",[v._v("entry：从配置的entry找出所有的入口文件")]),v._v(" "),a("li",[v._v("编译模块：从入口出发，然后根据模块间的引用，递归的进行编译，得到模块间的依赖关系")]),v._v(" "),a("li",[v._v("转译模块：对不同类型的文件调用loader进行转译，最终转化为JavaScript")]),v._v(" "),a("li",[v._v("输出资源：根据模块的依赖关系，输出一个或多个chunk，然后把chunk代码输出到单独的文件")]),v._v(" "),a("li",[v._v("完成输出：根据配置的输出路径和输出文件名，把编译好的chunk文件输出到对应路径")])])])}),[],!1,null,null,null);e.default=r.exports}}]);